"""
sortedlist stub file
"""
from abc import ABCMeta, abstractmethod
from typing import List, Any, Iterable, Callable, Union, Tuple, Optional, TypeVar


class Comparable(metaclass=ABCMeta):
    @abstractmethod
    def __lt__(self, other: Any) -> bool: ...

"""
Type Variable with bound that all types substituted
for CT must contain a __lt__ method. This
Ensures all types substituing CT are comparable, but
does NOT guarentee all types passed as CT into a function
are comparable to each other.
"""
CT  = TypeVar('CT', bound=Comparable)


def recursive_repr(func: Callable) -> Callable: ...


class SortedList(MutableSequence):
    def __init__(self, iterable: Iterable[CT]) -> None: ...
    def __new__(self,
                iterable: Iterable[CT],
                key: Callable) -> Union[SortedList, SortedListWithKey]: ...
    def key(self) -> None: ...
    def _reset(self, load: int) -> None: ...
    def clear(self) -> None: ...
    def add(self, val: CT) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[CT]) -> None: ...
    def __contains__(self, val: CT) -> bool: ...
    def discard(self, val: CT) -> None: ...
    def remove(self, val: CT) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _loc(self, pos: int, idx: int) -> int: ...
    def _pos(self, idx: int) -> Tuple[int, int]: ...
    def _build_index(self) -> None: ...
    def __delitem__(self, idx: int) -> None: ...
    def __getitem__(self, idx: int) -> Union[CT, List[CT]]: ...
    def _check_order(self, idx: int, val: CT) -> None: ...
    def __setitem__(self, index: int, value: CT) -> None: ...
    def __iter__(self) -> Iterable[CT]: ...
    def __reversed__(self) -> Iterable[CT]: ...
    def islice(self, start: int=None,
               stop: int=None,
               reverse: bool=False) -> Iterable[CT]: ...
    def _islice(self, min_pos: int,
                min_idx: int,
                max_pos: int,
                max_idx: int,
                reverse: bool) -> Iterable[CT]: ...
    def irange(self, minimum: Optional[CT]=None,
               maximum: Optional[CT]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Iterable[CT]: ...
    def __len__(self) -> int: ...
    def bisect_left(self, val: CT) -> int: ...
    def bisect_right(self, val: CT) -> int: ...
    def count(self, val: CT) -> int: ...
    def copy(self) -> SortedList: ...
    def append(self, val: CT) -> None: ...
    def extend(self, values: Union[Tuple[CT], List[CT]]) -> None: ...
    def insert(self, idx: int, val: CT) -> None: ...
    def pop(self, idx: int=-1) -> CT: ...
    def index(self, val: CT,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[CT], List[CT]]) -> SortedList: ...
    def __iadd__(self, that: Union[Tuple[CT], List[CT]]) -> SortedList: ...
    def __mul__(self, that: Union[Tuple[CT], List[CT]]) -> SortedList:  ...
    def __imul__(self, that: Union[Tuple[CT], List[CT]]) -> SortedList : ...
    def _make_cmp(self, seq_op: Callable, doc: str) -> Callable: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...


def identity(value: Any) -> Any: ...


class SortedListWithKey(SortedList):
    def __init__(self, iterable: Iterable[CT]) -> None: ...
    def __new__(cls, iterable: Optional[Iterable[CT]]=None,
                key=identity) -> SortedListWithKey: ...
    def key(self) -> Callable: ...
    def clear(self) -> None: ...
    def add(self, val: CT) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[CT]) -> None: ...
    def __contains__(self, val: CT) -> bool: ...
    def discard(self, val: CT) -> None: ...
    def remove(self, val: CT) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _check_order(self, idx: int,
                     key: CT,
                     val: CT) -> None: ...
    def __setitem__(self, index: int,
                    value: CT) -> None: ...
    def irange(self, minimum: Optional[CT]=None,
               maximum: Optional[CT]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Callable: ...
    def irange_key(self, min_key: Optional[CT]=None,
                   max_key: Optional[CT]=None,
                   inclusive: Optional[Tuple[bool, bool]]=(True, True),
                   reverse: Optional[bool]=False) -> Iterable[CT]: ...
    def bisect_left(self, val: CT) -> int: ...
    def bisect_right(self, val: CT) -> int: ...
    def bisect_key_left(self, key: CT) -> int: ...
    def bisect_key_right(self, key: CT) -> int: ...
    def count(self, val: CT) -> int: ...
    def copy(self) -> SortedListWithKey: ...
    def append(self, val: CT) -> None: ...
    def extend(self, values: Iterable[CT]) -> None: ...
    def insert(self, idx: int, val: CT) -> None: ...
    def index(self, val: CT,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[CT], List[CT]]) -> SortedListWithKey: ...
    def __mul__(self, that: Union[Tuple[CT], List[CT]]) -> SortedListWithKey: ...
    def __imul__(self, that: Union[Tuple[CT], List[CT]]) -> SortedListWithKey: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...
