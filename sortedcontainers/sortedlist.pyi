"""
sortedlist stub file
"""
from typing import List, Any, Iterable, Callable, Union, Tuple, Optional
Orderable = Union[int,float,str]

def recursive_repr(func: Callable) -> Callable: ...


class SortedList(MutableSequence):
    def __init__(self, iterable: Iterable[Orderable]) -> None: ...
    def __new__(self,
                iterable: Iterable[Orderable],
                key: Callable) -> Union[SortedList, SortedListWithKey]: ...
    def key(self) -> None: ...
    def _reset(self, load: int) -> None: ...
    def clear(self) -> None: ...
    def add(self, val: Orderable) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[Orderable]) -> None: ...
    def __contains__(self, val: Orderable) -> bool: ...
    def discard(self, val: Orderable) -> None: ...
    def remove(self, val: Orderable) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _loc(self, pos: int, idx: int) -> int: ...
    def _pos(self, idx: int) -> Tuple[int, int]: ...
    def _build_index(self) -> None: ...
    def __delitem__(self, idx: int) -> None: ...
    def __getitem__(self, idx: int) -> Union[Orderable, List[Orderable]]: ...
    def _check_order(self, idx: int, val: Orderable) -> None: ...
    def __setitem__(self, index: int, value: Orderable) -> None: ...
    def __iter__(self) -> Iterable[Orderable]: ...
    def __reversed__(self) -> Iterable[Orderable]: ...
    def islice(self, start: int=None,
               stop: int=None,
               reverse: bool=False) -> Iterable[Orderable]: ...
    def _islice(self, min_pos: int,
                min_idx: int,
                max_pos: int,
                max_idx: int,
                reverse: bool) -> Iterable[Orderable]: ...
    def irange(self, minimum: Optional[Orderable]=None,
               maximum: Optional[Orderable]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Iterable[Orderable]: ...
    def __len__(self) -> int: ...
    def bisect_left(self, val: Orderable) -> int: ...
    def bisect_right(self, val: Orderable) -> int: ...
    def count(self, val: Orderable) -> int: ...
    def copy(self) -> SortedList: ...
    def append(self, val: Orderable) -> None: ...
    def extend(self, values: Union[Tuple[Orderable], List[Orderable]]) -> None: ...
    def insert(self, idx: int, val: Orderable) -> None: ...
    def pop(self, idx: int=-1) -> Orderable: ...
    def index(self, val: Orderable,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedList: ...
    def __iadd__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedList: ...
    def __mul__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedList:  ...
    def __imul__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedList : ...
    def _make_cmp(self, seq_op: Callable, doc: str) -> Callable: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...


def identity(value: Any) -> Any: ...


class SortedListWithKey(SortedList):
    def __init__(self, iterable: Iterable[Orderable]) -> None: ...
    def __new__(cls, iterable: Optional[Iterable[Orderable]]=None,
                key=identity) -> SortedListWithKey: ...
    def key(self) -> Callable: ...
    def clear(self) -> None: ...
    def add(self, val: Orderable) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[Orderable]) -> None: ...
    def __contains__(self, val: Orderable) -> bool: ...
    def discard(self, val: Orderable) -> None: ...
    def remove(self, val: Orderable) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _check_order(self, idx: int,
                     key: Orderable,
                     val: Orderable) -> None: ...
    def __setitem__(self, index: int,
                    value: Orderable) -> None: ...
    def irange(self, minimum: Optional[Orderable]=None,
               maximum: Optional[Orderable]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Callable: ...
    def irange_key(self, min_key: Optional[Orderable]=None,
                   max_key: Optional[Orderable]=None,
                   inclusive: Optional[Tuple[bool, bool]]=(True, True),
                   reverse: Optional[bool]=False) -> Iterable[Orderable]: ...
    def bisect_left(self, val: Orderable) -> int: ...
    def bisect_right(self, val: Orderable) -> int: ...
    def bisect_key_left(self, key: Orderable) -> int: ...
    def bisect_key_right(self, key: Orderable) -> int: ...
    def count(self, val: Orderable) -> int: ...
    def copy(self) -> SortedListWithKey: ...
    def append(self, val: Orderable) -> None: ...
    def extend(self, values: Iterable[Orderable]) -> None: ...
    def insert(self, idx: int, val: Orderable) -> None: ...
    def index(self, val: Orderable,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedListWithKey: ...
    def __mul__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedListWithKey: ...
    def __imul__(self, that: Union[Tuple[Orderable], List[Orderable]]) -> SortedListWithKey: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...
