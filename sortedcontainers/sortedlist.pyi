"""
sortedlist stub file
"""
from typing import Sequence, MutableSequence
from typing import List, Any, Iterable, Callable, Union, Tuple, Optional, TypeVar

T = TypeVar('T')

def recursive_repr(func: Callable) -> Callable: ...


class SortedList(MutableSequence):
    def __init__(self, iterable: Iterable[T]) -> None: ...
    def __new__(self,
                iterable: Iterable[T],
                key: Callable) -> Union[SortedList, SortedListWithKey]: ...
    def key(self) -> None: ...
    def _reset(self, load: int) -> None: ...
    def clear(self) -> None: ...
    def add(self, val: T) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[T]) -> None: ...
    def __contains__(self, val: T) -> bool: ...
    def discard(self, val: T) -> None: ...
    def remove(self, val: T) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _loc(self, pos: int, idx: int) -> int: ...
    def _pos(self, idx: int) -> Tuple[int, int]: ...
    def _build_index(self) -> None: ...
    def __delitem__(self, idx: Any) -> None: ...
    def __getitem__(self, idx: Any) -> Union[T, List[T]]: ...
    def _check_order(self, idx: int, val: T) -> None: ...
    def __setitem__(self, index: Any, value: T) -> None: ...
    def __iter__(self) -> Any: ...
    def __reversed__(self) -> Any: ...
    def islice(self, start: int=None,
               stop: int=None,
               reverse: bool=False) -> Iterable[T]: ...
    def _islice(self, min_pos: int,
                min_idx: int,
                max_pos: int,
                max_idx: int,
                reverse: bool) -> Iterable[T]: ...
    def irange(self, minimum: Optional[T]=None,
               maximum: Optional[T]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Iterable[T]: ...
    def __len__(self) -> int: ...
    def bisect_left(self, val: T) -> int: ...
    def bisect_right(self, val: T) -> int: ...
    def count(self, val: T) -> int: ...
    def copy(self) -> SortedList: ...
    def append(self, val: T) -> None: ...
    def extend(self, values: Iterable[T]) -> None: ...
    def insert(self, idx: int, val: T) -> None: ...
    def pop(self, idx: int=-1) -> T: ...
    def index(self, val: T,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[T], List[T]]) -> SortedList: ...
    def __iadd__(self, that: Iterable[T]) -> SortedList: ...
    def __mul__(self, that: Union[Tuple[T], List[T]]) -> SortedList:  ...
    def __imul__(self, that: Union[Tuple[T], List[T]]) -> SortedList : ...
    def _make_cmp(self, seq_op: Callable, doc: str) -> Callable: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...


def identity(value: Any) -> Any: ...


class SortedListWithKey(SortedList):
    def __init__(self, iterable: Iterable[T]) -> None: ...
    def __new__(cls, iterable: Optional[Iterable[T]]=None,
                key=identity) -> SortedListWithKey: ...
    def key(self) -> Any: ...
    def clear(self) -> None: ...
    def add(self, val: T) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[T]) -> None: ...
    def __contains__(self, val: T) -> bool: ...
    def discard(self, val: T) -> None: ...
    def remove(self, val: T) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    # _check_order violates Liskov and cant be type checked
    def _check_order(self, idx, key, val): ...
    def __setitem__(self, index: Any,
                    value: T) -> None: ...
    def irange(self, minimum: Optional[T]=None,
               maximum: Optional[T]=None,
               inclusive: Optional[Tuple[bool,bool]]=(True, True),
               reverse: Optional[bool]=False) -> Iterable[T]: ...
    def irange_key(self, min_key: Optional[T]=None,
                   max_key: Optional[T]=None,
                   inclusive: Optional[Tuple[bool, bool]]=(True, True),
                   reverse: Optional[bool]=False) -> Iterable[T]: ...
    def bisect_left(self, val: T) -> int: ...
    def bisect_right(self, val: T) -> int: ...
    def bisect_key_left(self, key: T) -> int: ...
    def bisect_key_right(self, key: T) -> int: ...
    def count(self, val: T) -> int: ...
    def copy(self) -> SortedListWithKey: ...
    def append(self, val: T) -> None: ...
    def extend(self, values: Iterable[T]) -> None: ...
    def insert(self, idx: int, val: T) -> None: ...
    def index(self, val: T,
              start: Optional[int]=None,
              stop: Optional[int]=None) -> int: ...
    def __add__(self, that: Union[Tuple[T], List[T]]) -> SortedListWithKey: ...
    def __mul__(self, that: Union[Tuple[T], List[T]]) -> SortedListWithKey: ...
    def __imul__(self, that: Union[Tuple[T], List[T]]) -> SortedListWithKey: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...
